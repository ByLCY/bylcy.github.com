[{"categories":["算法学习"],"content":"个人认为回溯算法就是一个不断试错，撤销、再试错的算法。本片文章将从N 皇后问题中学习回溯算法","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法学习"],"content":"N皇后问题 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。N 皇后练习题 八皇后的一种解法\"\r八皇后的一种解法\r 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 // 力扣的例子 输入：4 输出：[ [\".Q..\", // 解法 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // 解法 2 \"Q...\", \"...Q\", \".Q..\"] ] 解释: 4 皇后问题存在两个不同的解法。 在国际象棋中皇后可以攻击八个方向上的敌人（上下左右、左上、右上、左下、右下）。 ","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:1:0","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法学习"],"content":"题解 ","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:2:0","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法学习"],"content":"深度优先搜索 根据题目可知道每一行只会有一个皇后，每个对角线上只有一个皇后，由此可以进行编码。首先大体思路是使用深度优先遍历所有可能位置，然后根据限制条件检查位置是否合适。 for (int row = 0; row \u003c n; row++) { for (int col = 0; col \u003c n; col++) { if (check(棋盘[i][j])) { 将当前位置保存; 到下一行检查是否有列合适; 恢复到本次更改; } } } 对上述伪代码进行优化得到如下代码： void dfs(int n, int row, vector\u003cstring\u003e\u0026 ans, vector\u003cvector\u003cstring\u003e\u003e res) { // n为棋盘大小 // row为当前行 // ans 为保存了到目前为止推算出的皇后位置 // res保存答案 if (row == n) { res.push_back(ans); return; } for (int col = 0; col \u003c n; col++) { if (check(row, col, n, ans)) { ans[row][col] = 'Q'; dfs(n, row + 1, ans); ans[row][col] = '.'; // 此步进行回溯 } } } ","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:2:1","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法学习"],"content":"通过条件剪支 然后就是解决check函数。根据题目的要求我们要检测皇后是否在同一列或同一条对角线上（之所以不用检查是否在同一行上，因为根据我们上面的函数我们是不可能同一时间在同一行上放两个皇后的）。由此我们可以提出两种思路，第一种是：每当准备安放皇后时就通过行和列来回推同一列和同一对角线的位置是否有皇后。第二种思路就是通过观察行和对角线的下标规律来检测是否满足条件。 通过第一种思路我们可以写出如下代码： bool check(int row, int col, int n, vector\u003cstring\u003e\u0026 ans) { // 检查之前的列是否存在皇后 for(int i = 0; i \u003c row; i++) { if (ans[i][col] == 'Q') { return false; } } // 检查从左上到右下对角线是否存在皇后 for(int i = row - 1, j = col - 1; i \u003e= 0 \u0026\u0026 j \u003e= 0; i--, j--) { if (ans[i][j] == 'Q') { return false; } } // 检查从右上到左下对角线是否存在皇后 for(int i = row - 1, j = col + 1; i \u003e= 0 \u0026\u0026 j \u003c n; i--, j++) { if (ans[i][j] == 'Q') { return false; } } return true; } 第二种思路的规律就是在同一列只会存在一个皇后，所以只要保存有皇后的列下标的集合就行了。而从左上到右下的对角线的行减去列的值相等，所以保存差的集合。最后右上到左下的对角线的行加上列的值相等，所以保存和的集合。一旦集合有重复就说明皇后的位置出错。代码如下： void backtrack(vector\u003cvector\u003cstring\u003e\u003e\u0026 res, vector\u003cstring\u003e\u0026 ans, unordered_set\u003cint\u003e\u0026 cls， unordered_set\u003cint\u003e\u0026 diagonalLR, unordered_set\u003cint\u003e\u0026 diagonalRL, int n, int row) { // 有皇后的集合 // cls列 // diagonalLR对角线左上到右下 // diagonalRL对角线右上到左下 if (n == row) { // 皇后的位置摆放完毕，保存当前解法 res.push_back(ans); return; } // 如果没有摆放完毕 for (int i = 0; i \u003c n; i++) { // 循环列 int dlr = row - i; int drl = row + i; if(cls.find(i) != cls.end() || diagonalLR.find(dlr) != diagonalLR.end() || diagonalRL.find(drl) != diagonalRL.end()) { continue; // 第row列i行会被其他皇后攻击到，跳过 } cls.insert(i); diagonalLR.insert(dlr); diagonalRL.insert(drl); ans[row][i] = 'Q'; backtrack(ans, queens, cls, diagonalLR, diagonalRL, n, row + 1); // 回溯 cls.erase(i); diagonalLR.erase(dlr); diagonalRL.erase(drl); ans[row][i] = '.'; } } ","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:2:2","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法学习"],"content":"答案 最后通过两种方法得到的解答如下： // 第一种 class Solution { public: bool check(int row, int col, int n, vector\u003cstring\u003e\u0026 ans) { for(int i = 0; i \u003c row; i++) { if (ans[i][col] == 'Q') { return false; } } for(int i = row - 1, j = col - 1; i \u003e= 0 \u0026\u0026 j \u003e= 0; i--, j--) { if (ans[i][j] == 'Q') { return false; } } for(int i = row - 1, j = col + 1; i \u003e= 0 \u0026\u0026 j \u003c n; i--, j++) { if (ans[i][j] == 'Q') { return false; } } return true; } void dfs(int n, int row, vector\u003cstring\u003e\u0026 ans, vector\u003cvector\u003cstring\u003e\u003e\u0026 res) { if (row == n) { res.push_back(ans); return; } for (int col = 0; col \u003c n; col++) { if (check(row, col, n, ans)) { ans[row][col] = 'Q'; dfs(n, row + 1, ans, res); ans[row][col] = '.'; } } } vector\u003cvector\u003cstring\u003e\u003e solveNQueens(int n) { auto res = vector\u003cvector\u003cstring\u003e\u003e(); auto ans = vector\u003cstring\u003e(n,string(n,'.')); dfs(n,0,ans,res); return res; } }; // 第二种 class Solution { public: vector\u003cvector\u003cstring\u003e\u003e solveNQueens(int n) { auto res = vector\u003cvector\u003cstring\u003e\u003e(); // 答案数组 auto ans = vector\u003cstring\u003e(n, string(n,'.')); // n个皇后的位置 auto cls = unordered_set\u003cint\u003e(); // 已经存放皇后的列 auto diagonalRL = unordered_set\u003cint\u003e(); // 已经存放皇后的对角线 从左上到右下 同一对角线上行-列的值相等 auto diagonalLR = unordered_set\u003cint\u003e(); // 已经存放皇后的对角线 从右上到左下 同一对角线上行+列的值相等 backtrack(res, ans,cls, diagonalRL, diagonalLR, n, 0); return ans; } void backtrack(vector\u003cvector\u003cstring\u003e\u003e\u0026 res, vector\u003cstring\u003e\u0026 ans, unordered_set\u003cint\u003e\u0026 cls, unordered_set\u003cint\u003e\u0026 diagonalRL, unordered_set\u003cint\u003e\u0026 diagonalLR, int n, int row) { if (n == row) { // 皇后的位置摆放完毕，保存当前解法 res.push_back(ans); return; } // 如果没有摆放完毕 for (int i = 0; i \u003c n; i++) { // 循环列 int dr = row - i; int dl = row + i; if(cls.find(i) != cls.end() || diagonalRL.find(dr) != diagonalRL.end() || diagonalLR.find(dl) != diagonalLR.end()) { continue; // 第row列i行会被其他皇后攻击到 } cls.insert(i); diagonalRL.insert(dr); diagonalLR.insert(dl); ans[row][i] = 'Q'; backtrack(ans, queens, cls, diagonalRL, diagonalLR, n, row + 1); // 回溯 cls.erase(i); diagonalRL.erase(dr); diagonalLR.erase(dl); ans[row][i] = '.'; } } }; ","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:2:3","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法学习"],"content":"回溯算法 我个人认为回溯算法就是在深度优先遍历的同时检测是否符合条件。回溯算法和深度优先算法不同的是回溯算法强调当前遍历的状态是否符合条件，而深度优先算法则更加偏重于遍历所有状态。也有人说回溯算法像决策树，在不满足条件时直接剪枝。不过我觉得思路都差不多，都是在遍历全部状态的时候去掉不满足条件的状态，以此节约资源。 在看完这篇算法之后不知你能否了解到回溯算法的大概思路呢？欢迎讨论和提出您宝贵的意见。 ","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:3:0","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["go-tutorial"],"content":"本人不才，虽然这个系列名为 go 教程，但实际上是我个人的知识回顾和学习记录","date":"2020-06-18","objectID":"/first-acquaintance-go/","tags":["go"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":["go-tutorial"],"content":"安装 go 编译器 前往 golang 官网下载对应平台的安装包。如果因为特殊原因进不去那么可以访问官方镜像。 在安装完成后把安装目录下的bin目录添加PATH中。golang 会把用户文件夹下的 go 文件夹作为 GPATH来使用，如果想要更换可以设置环境变量 GOPATH 的值为你想要的目录，然后再目录下新建src、pkg和bin三个文件夹（在高版本下会自动创建和添加 bin 目录）。 ","date":"2020-06-18","objectID":"/first-acquaintance-go/:1:0","tags":["go"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":["go-tutorial"],"content":"Hello World 按照惯例我们第一个程序就是Hello World。在记事本中将下列代码输入进去并且保存为 HelloWorld.go ，保存时注意将编码调整为UTF-8。 package main import \"fmt\" func main() { fmt.Println(\"Hello World!!!\") } 由于 golang 是编译型语言所以要运行我们的代码就要先编译程序。 在按住 shift 的同时按下鼠标右键，选择“在此处打开 powershell 窗口”，然后输入 go build HelloWorld.go就会编译出 HelloWorld.exe 文件，在，命令行中输入 .\\HelloWorld.exe。你将会看见如下输出： Hello World!!! 技巧\r\r可以使用 go run HelloWorld.go 直接编译并运行程序。\r\r 接下来我们通过这个程序来简单了解一下 go 的大致语法。 ","date":"2020-06-18","objectID":"/first-acquaintance-go/:2:0","tags":["go"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":["go-tutorial"],"content":"包的创建 go 程序都是由一个个包组成的。在我们的程序中，第一行package main就相当于创建了一个叫 main 的包。main 包会比其他包要特殊，因为 go 执行程序的入口是 main 函数，而想要 main 函数被执行的话，那么 main函数 必须位于 main 包下。 示例\r\r当包名不为 main 时： package test import \"fmt\" func main() { fmt.Println(\"Hello World!!!\") } 运行效果： non-main package\"\rnon-main package\r\r当没有 main 函数时： package main import \"fmt\" func test() { fmt.Println(\"Hello World!!!\") } 运行效果： non-main function\"\rnon-main function\r\r以上例子证明：如果要写一个可执行程序的话程序的入口必须是在 main 包下的 main 函数。 \r\r 技巧\r\r使用 visual studio code 编辑器的体验会比记事本更好。\r\r ","date":"2020-06-18","objectID":"/first-acquaintance-go/:2:1","tags":["go"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":["go-tutorial"],"content":"包的导入 第三行的 import “fmt” 的作用是导入 fmt 包，这个包是 go 语言自带的包，无需另外下载。 导入包的语法还有 import () 在括号中可以填入多个包。 import ( \"package1\" \"package2\" \"package3\" ) 信息\r\rfmt 包里是用于格式化 I/O 的函数，类似于 C 语言的 printf 和 scanf 。\r\r 如果你学过其它编程语言，那么你会发现 go 语言的格式规范较为严格。在 go 中不允许导入无用包和定义未使用的变量，否则的话会在编译阶段报错。你可以用 _ 来表示你只需要使用包里面的 init函数。导入的包也可以在导入是重命名或者是直接导入全部函数。 import ( _ \"database/sql\" // 只使用初始化函数 f \"flag\" // 改名为 f，调用时用 f.func 的形式 \"fmt\" // 正常导入，调用时用 fmt.func 的形式 . \"net/http\" // 直接可以使用包内函数，不需要通过 package.func 的方式调用 ) ","date":"2020-06-18","objectID":"/first-acquaintance-go/:2:2","tags":["go"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":["go-tutorial"],"content":"函数 函数是代码复用的重要手段。函数的定义格式 func 函数名(参数列表) 返回值 { 函数体 } 在我们的 HelloWorld 程序中 的 main 函数的参数了返回值都没有填写，说明定义的这个函数没有参数和返回值。参数的传递一般有两种形式——值传递和引用传递。值传递就是将实参的值传递给形参，引用传递则是将地址传递给形参。值传递不会改变原变量，而引用传递会改变。在 golang 中一般默认为值传递。 函数的闭包和导出。函数名的第一个字母为大写说明此函数导出，导出的函数可以方便的被其它程序引用。与此相反函数名第一个字母为小写，则说明此函数为闭包。在其它程序导入此包时无法直接引用此函数。 ","date":"2020-06-18","objectID":"/first-acquaintance-go/:2:3","tags":["go"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":["go-tutorial"],"content":"结语 本篇文章通过一个HelloWorld程序简单且初略的说明了 go 程序的大概结构。还有许多地方是没有讲清楚，甚至是没有讲的。这个教程将会是一个系列待我在后面慢慢补足。 本系列虽然名为教程，但实际上是我个人的知识回顾整理。且这是本人第一次写blog，还有什么不足之处还望大伙门能在评论区提出来，望大家共同进步。 ","date":"2020-06-18","objectID":"/first-acquaintance-go/:3:0","tags":["go"],"title":"go语言初识","uri":"/first-acquaintance-go/"}]