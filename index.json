[{"categories":["读书笔记"],"content":"这是本人读编译原理的读书笔记。这篇笔记的结构就是按照书本的结构来写的。","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"1 语言处理器 语言处理器分为编译器和解释器。编译器是阅读以某一种语言编写的程序，并把该程序翻译成等价的、用另一种语言编写的程序。解释器是直接将用户的输入转换成对应的操作。 编译器和解释器比较如下表： 编译器 解释器 编译速度 慢 快 目标程序执行速度 快 慢 错误诊断效果 好 差 除了编译器之外，创建一个目标程序还要一些其他程序——将程序的多个模块聚合在一起的预处理程序；如果编译后输出的是汇编语言的话还会存在汇编器；连接器解决外部内存地址问题；加载器把所有目标程序放入内存中。 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:1:0","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"2 编译器结构 编译器分为前端（front end）分析和后端（back end）综合。 分析（analysis）部分是把源程序分解为多个组成要素，并在这些要素之上加上语法结构。如果分析部分发现错误还会给出必要的错误信息。分析部分还会收集有关源程序的信息，并存储在一个名为符号表的数据结构中。 综合（synthesis）部分根据主键表示和符号表中的信息来构建用户期待的程序。 如果我们更加详细的研究编译过程，我们会发现他顺序的执行了一组步骤，其中优化步骤是可选的，如下图所示： ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:2:0","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"2.1 词法分析 编译器的第一个步骤称为词法分析或扫描。此步读入源程序字符流，并将它们组织成有意义的词素。对于每个词素词法分析器都会生成如下的词法单元的输出： \u003ctoken-name, attribute-value\u003e 书上举了如下一个例子： position = initial + rate * 60 在经过处理后就会变为如下形式： \u003cid, 1\u003e \u003c=\u003e \u003cid, 2\u003e \u003c+\u003e \u003cid, 3\u003e \u003c*\u003e \u003c60\u003e 其中的变量名都存入了符号表中： 1 position … 2 initial … 3 rate … … … … ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:2:1","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"2.2 语法分析 编译器的第二个步骤为语法分析或叫解析。语法分析器使用由词法分析器生成的词法单元第一个分量来创建语法树。语法树的每个内部节点表示一个运算，而该节点的子节点表示运算的分量。上节的例子可以表示为： ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:2:2","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"2.3 语义分析 语义分析器使用语法树和符号表中的信息来检查程序是否和语言定义的语义一致。同时它会收集类型信息，并将信息放入语法树或符号表中。 语义分析的一个重要作用是类型检查。上节的语法树经过此节的处理后就变成如下形式。 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:2:3","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"2.4 中间代码生成 源程序翻译成目标代码的过程中会生成多种中间表示。一般在语法分析和语义分析后编译器会生成一个明确的低级的或类机器语言的中间表示。这个中间表示要由两个重要的性质：易于生成和能够简单翻译为目标机器是的语言。 在书中第六章将介绍三地址代码的中间表示形式。类似于汇编语言的指令组成，每个指令具有三个运算分量。前面的例子可以表示为： t1 = inttofloat(60) t2 = id3 * t1 t3 = id2 + t2 id1 = t3 关于三地址指令由三点需要注意： 右部最多有一个运算符 编译器应该生成一个临时的名字存放计算得到的值 有些指令的运算分量小于三个 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:2:4","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"2.5 代码优化 机器无关的代码优化视图改进中间代码，以生成更好的目标代码（更好不一定意味着更快，也可能是其他目标）。不同的编译器对代码的优化工作量相差巨大。我们将上一节的三地址指令进行简单的优化可得到如下代码： t1 = id3 * 60.0 id1 = id2 + t1 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:2:5","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"2.6 代码生成 代码生成器将中间表示映射到目标语言。如果目标语言是机器代码，那就必须为程序使用的每个变量选择寄存器或内存位置。代码生成的一个至关重要的方面是合理分配寄存器。上节代码翻译成如下机器码： LDF R2, id3 MULF R2, R2, #60.0 LDF R1, id2 ADDF R1, R1, R2 STF id1, R1 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:2:6","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"2.7 符号表管理 编译器的重要功能之一是记录源程序中使用的变量名字，并收集和每个名字相关的信息。这些属性可以提供一个名字的存储分配、类型、作用域等信息。对于过程名字这些信息还包括：参数类型、数量、参数传递方法以及返回值类型。而存储这些信息的数据结构应该能够允许编译器迅速的找到每个名字的记录，并进行操作。 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:2:7","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"2.8 组合成趟 以上是一个编译器的逻辑组成方式。在特定实现中，多个步骤可以被组合成一趟（pass）。每趟读入一个输入文件并产生一个输出文件。比如，前端步骤中的词法分析、语法分析、语义分析，以及中间代码生成可以组合成一趟。代码优化可以作为一个可选的趟。然后可以有一个为特定目标机生成代码的后端趟。 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:2:8","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"2.9 编译器构造工具 编译器开发和其他任何软件开发一样，写编译器的人可以充分利用现代的软件开发环境。除了一些通用软件外，任猛还创建了一些更加专业的的工具来实现编译器的不同阶段。一些常用的编译器构造工具包括： 语法分析器的生成工具 扫描器的生成工具 语法制导的翻译引擎 代码生成器的生成器 数据流分析引擎 编译构造工具集 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:2:9","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"3 程序设计语言发展历程 构建编译器的相关科学 编译技术应用 这三节介绍了程序设计语言的发展和语言的发展对编译器的影响和一些编译器技术的应用等。这些在书中可以详细了解，我在此就不做整理了。 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:3:0","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"4 程序设计语言基础 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:4:0","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"4.1 静态和动态的区别 如果一个语言使用的策略支持编译器静态的做某个决定，那么称这个语言使用了一个静态（static）策略，或者称这个问题在编译时刻（compile time）就决定了。另一方面一个语言只允许在允许程序在运行时候做出决定的策略叫动态策略（dynamic policy），或被认为需要在运行时刻（run time）做出决定。 关于作用域。x的一个声明的作用域是指程序的一个区域，在其中对于x的使用都指向这个声明。如果仅通过阅读程序就可以确定一个声明的作用域，那么这个语言使用二点是静态作用域。如果是动态作用域，那么程序运行时x的使用会指向x几个声明中的其中一个。 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:4:1","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"4.2 环境与状态 环境：是一个名字到存储位置的映射。 状态：是从内存位置到它们的值的映射。 一般来说名字到位置的绑定和位置到值的绑定都是动态的。不过在声明常量值的时候，从位置到值的绑定就是静态的了。 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:4:2","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"4.3 静态作用域和块结构 书上举例了C语言的静态作用域和块结构。 C语言的静态作用域： 一个C程序由一个顶层的变量和函数声明的序列组成。 函数内部可以声明变量，变量包括局部变量和参数。每个这样的声明的作用域被限制在它们所出现的那个函数内。 名字x的一个顶层声明的作用域包括其后的所有程序。但是如果一个函数中也有一个x的声明，那么函数中的语句就不可能指向顶层声明。 C语言块的语法： 块是个语句。块可以出现在其它类型语句所能出现的任何地方。 一个块包含了一个声明序列，然后再跟着一个语句序列。这些都被用一对括号包裹起来。 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:4:3","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"4.4 显式访问控制 类和结构为它们的成员添加了新的作用域。如果由一个对象p，那么p.x就是指定的对象p中的x属性。 一般来说可以通过public、private和protected这样的关键字来显式的控制访问。像C++和Java这样的面向对象的语言可以通过限制访问来实现封装。 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:4:4","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"4.5 动态作用域 从技术上来讲，如果一个作用域策略依赖于一个或多个只有在程序执行时刻才能知道的元素，那么就说他是动态的。不过，术语的动态作用域一般是指：对一个名字x的使用是指向的最近被调用但还没有终止且声明了x的过程中的这个声明。这种类型的动态作用域一般只会在特殊情况下出现。 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:4:5","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"4.6 参数传递机制 参数的值引用。这种传递会对实参进行求值（如果传递的是表达式）或拷贝。这些值会被放在属于被调用者的形参内存地址上。被调用的值的改变只限于被调用的过程中，不会改变实参的值。 引用调用。此种调用中实参的内存地址会被传递到相应的形式参数上，。从而导致对形参的改变会作用在实参上。 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:4:6","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["读书笔记"],"content":"4.7 别名 像引用调用和类似的其他方法会导致多个形式参数同时指向一个位置。这种情况下的变量为会被叫做另一个变量的别名。这样不论改变了谁的值都会反应在同一个内存位置上。 ","date":"2020-09-30","objectID":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/:4:7","tags":["笔记","编译原理","读书"],"title":"读书笔记 编译原理 第一章 引论","uri":"/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA/"},{"categories":["算法学习"],"content":"个人认为回溯算法就是一个不断试错，撤销、再试错的算法。本片文章将从N 皇后问题中学习回溯算法","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法学习"],"content":"N皇后问题 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。N 皇后练习题 八皇后的一种解法\"\r八皇后的一种解法\r 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 // 力扣的例子 输入：4 输出：[ [\".Q..\", // 解法 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // 解法 2 \"Q...\", \"...Q\", \".Q..\"] ] 解释: 4 皇后问题存在两个不同的解法。 在国际象棋中皇后可以攻击八个方向上的敌人（上下左右、左上、右上、左下、右下）。 ","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:1:0","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法学习"],"content":"题解 ","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:2:0","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法学习"],"content":"深度优先搜索 根据题目可知道每一行只会有一个皇后，每个对角线上只有一个皇后，由此可以进行编码。首先大体思路是使用深度优先遍历所有可能位置，然后根据限制条件检查位置是否合适。 for (int row = 0; row \u003c n; row++) { for (int col = 0; col \u003c n; col++) { if (check(棋盘[i][j])) { 将当前位置保存; 到下一行检查是否有列合适; 恢复到本次更改; } } } 对上述伪代码进行优化得到如下代码： void dfs(int n, int row, vector\u003cstring\u003e\u0026 ans, vector\u003cvector\u003cstring\u003e\u003e res) { // n为棋盘大小 // row为当前行 // ans 为保存了到目前为止推算出的皇后位置 // res保存答案 if (row == n) { res.push_back(ans); return; } for (int col = 0; col \u003c n; col++) { if (check(row, col, n, ans)) { ans[row][col] = 'Q'; dfs(n, row + 1, ans); ans[row][col] = '.'; // 此步进行回溯 } } } ","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:2:1","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法学习"],"content":"通过条件剪支 然后就是解决check函数。根据题目的要求我们要检测皇后是否在同一列或同一条对角线上（之所以不用检查是否在同一行上，因为根据我们上面的函数我们是不可能同一时间在同一行上放两个皇后的）。由此我们可以提出两种思路，第一种是：每当准备安放皇后时就通过行和列来回推同一列和同一对角线的位置是否有皇后。第二种思路就是通过观察行和对角线的下标规律来检测是否满足条件。 通过第一种思路我们可以写出如下代码： bool check(int row, int col, int n, vector\u003cstring\u003e\u0026 ans) { // 检查之前的列是否存在皇后 for(int i = 0; i \u003c row; i++) { if (ans[i][col] == 'Q') { return false; } } // 检查从左上到右下对角线是否存在皇后 for(int i = row - 1, j = col - 1; i \u003e= 0 \u0026\u0026 j \u003e= 0; i--, j--) { if (ans[i][j] == 'Q') { return false; } } // 检查从右上到左下对角线是否存在皇后 for(int i = row - 1, j = col + 1; i \u003e= 0 \u0026\u0026 j \u003c n; i--, j++) { if (ans[i][j] == 'Q') { return false; } } return true; } 第二种思路的规律就是在同一列只会存在一个皇后，所以只要保存有皇后的列下标的集合就行了。而从左上到右下的对角线的行减去列的值相等，所以保存差的集合。最后右上到左下的对角线的行加上列的值相等，所以保存和的集合。一旦集合有重复就说明皇后的位置出错。代码如下： void backtrack(vector\u003cvector\u003cstring\u003e\u003e\u0026 res, vector\u003cstring\u003e\u0026 ans, unordered_set\u003cint\u003e\u0026 cls， unordered_set\u003cint\u003e\u0026 diagonalLR, unordered_set\u003cint\u003e\u0026 diagonalRL, int n, int row) { // 有皇后的集合 // cls列 // diagonalLR对角线左上到右下 // diagonalRL对角线右上到左下 if (n == row) { // 皇后的位置摆放完毕，保存当前解法 res.push_back(ans); return; } // 如果没有摆放完毕 for (int i = 0; i \u003c n; i++) { // 循环列 int dlr = row - i; int drl = row + i; if(cls.find(i) != cls.end() || diagonalLR.find(dlr) != diagonalLR.end() || diagonalRL.find(drl) != diagonalRL.end()) { continue; // 第row列i行会被其他皇后攻击到，跳过 } cls.insert(i); diagonalLR.insert(dlr); diagonalRL.insert(drl); ans[row][i] = 'Q'; backtrack(ans, queens, cls, diagonalLR, diagonalRL, n, row + 1); // 回溯 cls.erase(i); diagonalLR.erase(dlr); diagonalRL.erase(drl); ans[row][i] = '.'; } } ","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:2:2","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法学习"],"content":"答案 最后通过两种方法得到的解答如下： // 第一种 class Solution { public: bool check(int row, int col, int n, vector\u003cstring\u003e\u0026 ans) { for(int i = 0; i \u003c row; i++) { if (ans[i][col] == 'Q') { return false; } } for(int i = row - 1, j = col - 1; i \u003e= 0 \u0026\u0026 j \u003e= 0; i--, j--) { if (ans[i][j] == 'Q') { return false; } } for(int i = row - 1, j = col + 1; i \u003e= 0 \u0026\u0026 j \u003c n; i--, j++) { if (ans[i][j] == 'Q') { return false; } } return true; } void dfs(int n, int row, vector\u003cstring\u003e\u0026 ans, vector\u003cvector\u003cstring\u003e\u003e\u0026 res) { if (row == n) { res.push_back(ans); return; } for (int col = 0; col \u003c n; col++) { if (check(row, col, n, ans)) { ans[row][col] = 'Q'; dfs(n, row + 1, ans, res); ans[row][col] = '.'; } } } vector\u003cvector\u003cstring\u003e\u003e solveNQueens(int n) { auto res = vector\u003cvector\u003cstring\u003e\u003e(); auto ans = vector\u003cstring\u003e(n,string(n,'.')); dfs(n,0,ans,res); return res; } }; // 第二种 class Solution { public: vector\u003cvector\u003cstring\u003e\u003e solveNQueens(int n) { auto res = vector\u003cvector\u003cstring\u003e\u003e(); // 答案数组 auto ans = vector\u003cstring\u003e(n, string(n,'.')); // n个皇后的位置 auto cls = unordered_set\u003cint\u003e(); // 已经存放皇后的列 auto diagonalRL = unordered_set\u003cint\u003e(); // 已经存放皇后的对角线 从左上到右下 同一对角线上行-列的值相等 auto diagonalLR = unordered_set\u003cint\u003e(); // 已经存放皇后的对角线 从右上到左下 同一对角线上行+列的值相等 backtrack(res, ans,cls, diagonalRL, diagonalLR, n, 0); return ans; } void backtrack(vector\u003cvector\u003cstring\u003e\u003e\u0026 res, vector\u003cstring\u003e\u0026 ans, unordered_set\u003cint\u003e\u0026 cls, unordered_set\u003cint\u003e\u0026 diagonalRL, unordered_set\u003cint\u003e\u0026 diagonalLR, int n, int row) { if (n == row) { // 皇后的位置摆放完毕，保存当前解法 res.push_back(ans); return; } // 如果没有摆放完毕 for (int i = 0; i \u003c n; i++) { // 循环列 int dr = row - i; int dl = row + i; if(cls.find(i) != cls.end() || diagonalRL.find(dr) != diagonalRL.end() || diagonalLR.find(dl) != diagonalLR.end()) { continue; // 第row列i行会被其他皇后攻击到 } cls.insert(i); diagonalRL.insert(dr); diagonalLR.insert(dl); ans[row][i] = 'Q'; backtrack(ans, queens, cls, diagonalRL, diagonalLR, n, row + 1); // 回溯 cls.erase(i); diagonalRL.erase(dr); diagonalLR.erase(dl); ans[row][i] = '.'; } } }; ","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:2:3","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["算法学习"],"content":"回溯算法 我个人认为回溯算法就是在深度优先遍历的同时检测是否符合条件。回溯算法和深度优先算法不同的是回溯算法强调当前遍历的状态是否符合条件，而深度优先算法则更加偏重于遍历所有状态。也有人说回溯算法像决策树，在不满足条件时直接剪枝。不过我觉得思路都差不多，都是在遍历全部状态的时候去掉不满足条件的状态，以此节约资源。 在看完这篇算法之后不知你能否了解到回溯算法的大概思路呢？欢迎讨论和提出您宝贵的意见。 ","date":"2020-09-22","objectID":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:3:0","tags":["算法","C++"],"title":"从N 皇后问题了解回溯算法","uri":"/%E4%BB%8En-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["go-tutorial"],"content":"本人不才，虽然这个系列名为 go 教程，但实际上是我个人的知识回顾和学习记录","date":"2020-06-18","objectID":"/first-acquaintance-go/","tags":["go","教程"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":["go-tutorial"],"content":"安装 go 编译器 前往 golang 官网下载对应平台的安装包。如果因为特殊原因进不去那么可以访问官方镜像。 在安装完成后把安装目录下的bin目录添加PATH中。golang 会把用户文件夹下的 go 文件夹作为 GPATH来使用，如果想要更换可以设置环境变量 GOPATH 的值为你想要的目录，然后再目录下新建src、pkg和bin三个文件夹（在高版本下会自动创建和添加 bin 目录）。 ","date":"2020-06-18","objectID":"/first-acquaintance-go/:1:0","tags":["go","教程"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":["go-tutorial"],"content":"Hello World 按照惯例我们第一个程序就是Hello World。在记事本中将下列代码输入进去并且保存为 HelloWorld.go ，保存时注意将编码调整为UTF-8。 package main import \"fmt\" func main() { fmt.Println(\"Hello World!!!\") } 由于 golang 是编译型语言所以要运行我们的代码就要先编译程序。 在按住 shift 的同时按下鼠标右键，选择“在此处打开 powershell 窗口”，然后输入 go build HelloWorld.go就会编译出 HelloWorld.exe 文件，在，命令行中输入 .\\HelloWorld.exe。你将会看见如下输出： Hello World!!! 技巧\r\r可以使用 go run HelloWorld.go 直接编译并运行程序。\r\r 接下来我们通过这个程序来简单了解一下 go 的大致语法。 ","date":"2020-06-18","objectID":"/first-acquaintance-go/:2:0","tags":["go","教程"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":["go-tutorial"],"content":"包的创建 go 程序都是由一个个包组成的。在我们的程序中，第一行package main就相当于创建了一个叫 main 的包。main 包会比其他包要特殊，因为 go 执行程序的入口是 main 函数，而想要 main 函数被执行的话，那么 main函数 必须位于 main 包下。 示例\r\r当包名不为 main 时： package test import \"fmt\" func main() { fmt.Println(\"Hello World!!!\") } 运行效果： non-main package\"\rnon-main package\r\r当没有 main 函数时： package main import \"fmt\" func test() { fmt.Println(\"Hello World!!!\") } 运行效果： non-main function\"\rnon-main function\r\r以上例子证明：如果要写一个可执行程序的话程序的入口必须是在 main 包下的 main 函数。 \r\r 技巧\r\r使用 visual studio code 编辑器的体验会比记事本更好。\r\r ","date":"2020-06-18","objectID":"/first-acquaintance-go/:2:1","tags":["go","教程"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":["go-tutorial"],"content":"包的导入 第三行的 import “fmt” 的作用是导入 fmt 包，这个包是 go 语言自带的包，无需另外下载。 导入包的语法还有 import () 在括号中可以填入多个包。 import ( \"package1\" \"package2\" \"package3\" ) 信息\r\rfmt 包里是用于格式化 I/O 的函数，类似于 C 语言的 printf 和 scanf 。\r\r 如果你学过其它编程语言，那么你会发现 go 语言的格式规范较为严格。在 go 中不允许导入无用包和定义未使用的变量，否则的话会在编译阶段报错。你可以用 _ 来表示你只需要使用包里面的 init函数。导入的包也可以在导入是重命名或者是直接导入全部函数。 import ( _ \"database/sql\" // 只使用初始化函数 f \"flag\" // 改名为 f，调用时用 f.func 的形式 \"fmt\" // 正常导入，调用时用 fmt.func 的形式 . \"net/http\" // 直接可以使用包内函数，不需要通过 package.func 的方式调用 ) ","date":"2020-06-18","objectID":"/first-acquaintance-go/:2:2","tags":["go","教程"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":["go-tutorial"],"content":"函数 函数是代码复用的重要手段。函数的定义格式 func 函数名(参数列表) 返回值 { 函数体 } 在我们的 HelloWorld 程序中 的 main 函数的参数了返回值都没有填写，说明定义的这个函数没有参数和返回值。参数的传递一般有两种形式——值传递和引用传递。值传递就是将实参的值传递给形参，引用传递则是将地址传递给形参。值传递不会改变原变量，而引用传递会改变。在 golang 中一般默认为值传递。 函数的闭包和导出。函数名的第一个字母为大写说明此函数导出，导出的函数可以方便的被其它程序引用。与此相反函数名第一个字母为小写，则说明此函数为闭包。在其它程序导入此包时无法直接引用此函数。 ","date":"2020-06-18","objectID":"/first-acquaintance-go/:2:3","tags":["go","教程"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":["go-tutorial"],"content":"结语 本篇文章通过一个HelloWorld程序简单且初略的说明了 go 程序的大概结构。还有许多地方是没有讲清楚，甚至是没有讲的。这个教程将会是一个系列待我在后面慢慢补足。 本系列虽然名为教程，但实际上是我个人的知识回顾整理。且这是本人第一次写blog，还有什么不足之处还望大伙门能在评论区提出来，望大家共同进步。 ","date":"2020-06-18","objectID":"/first-acquaintance-go/:3:0","tags":["go","教程"],"title":"go语言初识","uri":"/first-acquaintance-go/"},{"categories":null,"content":"关于本人 非常高兴你能够访问我的网站 😜 本人创建此网站的目的是为了记录自己的点滴学习，和督促自己吸收并产出知识。我这是第一次在网上写文章还多有不足。 欢迎大家交流学习~~ ","date":"2020-06-08","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"感谢 感谢主题作者Dillon和各位贡献成员，也非常感谢免费第三方服务和开源作者。 ","date":"2020-06-08","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"小小的愿望 本人计算机科学与技术专业最近临近毕业，觉得有合适的工作可以发邮件给我哟~~ ","date":"2020-06-08","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"}]