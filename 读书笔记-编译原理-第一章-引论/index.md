# 读书笔记 编译原理 第一章 引论


<!--more-->

## 1 语言处理器

语言处理器分为**编译器**和**解释器**。编译器是阅读以某一种语言编写的程序，并把该程序翻译成等价的、用另一种语言编写的程序。解释器是直接将用户的输入转换成对应的操作。

编译器和解释器比较如下表：

|                  | 编译器 | 解释器 |
| ---------------- | ------ | ------ |
| 编译速度         | 慢     | 快     |
| 目标程序执行速度 | 快     | 慢     |
| 错误诊断效果     | 好     | 差     |

除了编译器之外，创建一个目标程序还要一些其他程序——将程序的多个模块聚合在一起的预处理程序；如果编译后输出的是汇编语言的话还会存在汇编器；连接器解决外部内存地址问题；加载器把所有目标程序放入内存中。
{{<mermaid>}}
graph LR;
	源程序 --> 预处理器 --> |经过预处理的源程序| 编译器 --> |目标汇编程序| 汇编器 --> |可重定位机器代码| 链接器/加载器 --> 目标机器代码
	A[库文件 可重定位对象文件] --> 链接器/加载器
{{</mermaid>}}

## 2 编译器结构

编译器分为前端（front end）分析和后端（back end）综合。

**分析**（analysis）部分是把源程序分解为多个组成要素，并在这些要素之上加上语法结构。如果分析部分发现错误还会给出必要的错误信息。分析部分还会收集有关源程序的信息，并存储在一个名为符号表的数据结构中。

**综合**（synthesis）部分根据主键表示和符号表中的信息来构建用户期待的程序。

如果我们更加详细的研究编译过程，我们会发现他顺序的执行了一组步骤，其中优化步骤是可选的，如下图所示：

{{<mermaid>}}
graph TB;
	A[输入] -->|字符流| B[词法分析器]
	B --> |符号流| C[语法分析]
	C --> |语法树| D[语义分析] --> |语法树| E[中间代码生成器] --> |中间表现形式| F[机器无关代码优化] --> |中间表现形式| G[代码生成器] --> |目标机器语言| H[机器相关代码优化器] -->|目标机器语言| I[输出]
	N[符号表]
{{</mermaid>}}

### 2.1 词法分析

编译器的第一个步骤称为**词法分析**或**扫描**。此步读入源程序字符流，并将它们组织成有意义的**词素**。对于每个词素词法分析器都会生成如下的词法单元的输出：

```
<token-name, attribute-value>
```

书上举了如下一个例子：

```C++
position = initial + rate * 60
```

在经过处理后就会变为如下形式：

```
<id, 1> <=> <id, 2> <+> <id, 3> <*> <60>
```

其中的变量名都存入了符号表中：

|      |          |      |
| ---- | -------- | ---- |
| 1    | position | ...  |
| 2    | initial  | ...  |
| 3    | rate     | ...  |
| ...  | ...      | ...  |

### 2.2 语法分析

编译器的第二个步骤为**语法分析**或叫**解析**。语法分析器使用由词法分析器生成的词法单元第一个分量来创建语法树。语法树的每个内部节点表示一个运算，而该节点的子节点表示运算的分量。上节的例子可以表示为：

{{<mermaid>}}
graph TB;
	A[ = ] --> B[<id, 1>]
	A --> C[+]
	C --> D[<id, 2>]
	C --> E[*]
	E --> F[<id, 3>]
	E --> 60
{{</mermaid>}}

### 2.3 语义分析

**语义分析器**使用语法树和符号表中的信息来检查程序是否和语言定义的语义一致。同时它会收集类型信息，并将信息放入语法树或符号表中。

语义分析的一个重要作用是类型检查。上节的语法树经过此节的处理后就变成如下形式。

{{<mermaid>}}
graph TB;
	A(=) --> B[<id, 1>]
	A --> C[+]
	C --> D[<id, 2>]
	C --> E[*]
	E --> F[<id, 3>]
	E --> inttofloat
	inttofloat --> 60
{{</mermaid>}}

### 2.4 中间代码生成

源程序翻译成目标代码的过程中会生成多种中间表示。一般在语法分析和语义分析后编译器会生成一个明确的低级的或类机器语言的中间表示。这个中间表示要由两个重要的性质：易于生成和能够简单翻译为目标机器是的语言。

在书中第六章将介绍三地址代码的中间表示形式。类似于汇编语言的指令组成，每个指令具有三个运算分量。前面的例子可以表示为：

```assembly
t1 = inttofloat(60)
t2 = id3 * t1
t3 = id2 + t2
id1 = t3
```

关于三地址指令由三点需要注意：

* 右部最多有一个运算符
* 编译器应该生成一个临时的名字存放计算得到的值
* 有些指令的运算分量小于三个

### 2.5 代码优化

机器无关的代码优化视图改进中间代码，以生成更好的目标代码（更好不一定意味着更快，也可能是其他目标）。不同的编译器对代码的优化工作量相差巨大。我们将上一节的三地址指令进行简单的优化可得到如下代码：

```assembly
t1 = id3 * 60.0
id1 = id2 + t1
```

### 2.6 代码生成

代码生成器将中间表示映射到目标语言。如果目标语言是机器代码，那就必须为程序使用的每个变量选择寄存器或内存位置。代码生成的一个至关重要的方面是合理分配寄存器。上节代码翻译成如下机器码：

```assembly
LDF  R2, id3
MULF R2, R2, #60.0
LDF  R1, id2
ADDF R1, R1, R2
STF  id1, R1
```



### 2.7 符号表管理

编译器的重要功能之一是记录源程序中使用的变量名字，并收集和每个名字相关的信息。这些属性可以提供一个名字的存储分配、类型、作用域等信息。对于过程名字这些信息还包括：参数类型、数量、参数传递方法以及返回值类型。而存储这些信息的数据结构应该能够允许编译器迅速的找到每个名字的记录，并进行操作。

### 2.8 组合成趟

以上是一个编译器的逻辑组成方式。在特定实现中，多个步骤可以被组合成**一趟**（pass）。每趟读入一个输入文件并产生一个输出文件。比如，前端步骤中的词法分析、语法分析、语义分析，以及中间代码生成可以组合成一趟。代码优化可以作为一个可选的趟。然后可以有一个为特定目标机生成代码的后端趟。

### 2.9 编译器构造工具

编译器开发和其他任何软件开发一样，写编译器的人可以充分利用现代的软件开发环境。除了一些通用软件外，任猛还创建了一些更加专业的的工具来实现编译器的不同阶段。一些常用的编译器构造工具包括：

1. 语法分析器的生成工具
2. 扫描器的生成工具
3. 语法制导的翻译引擎
4. 代码生成器的生成器
5. 数据流分析引擎
6. 编译构造工具集

## 3 程序设计语言发展历程 构建编译器的相关科学 编译技术应用

这三节介绍了程序设计语言的发展和语言的发展对编译器的影响和一些编译器技术的应用等。这些在书中可以详细了解，我在此就不做整理了。

## 4 程序设计语言基础

### 4.1 静态和动态的区别

如果一个语言使用的策略支持编译器静态的做某个决定，那么称这个语言使用了一个**静态**（static）策略，或者称这个问题在**编译时刻**（compile time）就决定了。另一方面一个语言只允许在允许程序在运行时候做出决定的策略叫**动态**策略（dynamic policy），或被认为需要在**运行时刻**（run time）做出决定。

关于作用域。x的一个声明的作用域是指程序的一个区域，在其中对于x的使用都指向这个声明。如果仅通过阅读程序就可以确定一个声明的作用域，那么这个语言使用二点是静态作用域。如果是动态作用域，那么程序运行时x的使用会指向x几个声明中的其中一个。

### 4.2 环境与状态

1. 环境：是一个名字到存储位置的映射。
2. 状态：是从内存位置到它们的值的映射。

一般来说名字到位置的绑定和位置到值的绑定都是动态的。不过在声明常量值的时候，从位置到值的绑定就是静态的了。

### 4.3 静态作用域和块结构

书上举例了C语言的静态作用域和块结构。

C语言的静态作用域：

1. 一个C程序由一个顶层的变量和函数声明的序列组成。
2. 函数内部可以声明变量，变量包括局部变量和参数。每个这样的声明的作用域被限制在它们所出现的那个函数内。
3. 名字x的一个顶层声明的作用域包括其后的所有程序。但是如果一个函数中也有一个x的声明，那么函数中的语句就不可能指向顶层声明。

C语言块的语法：

1. 块是个语句。块可以出现在其它类型语句所能出现的任何地方。
2. 一个块包含了一个声明序列，然后再跟着一个语句序列。这些都被用一对括号包裹起来。

### 4.4 显式访问控制

类和结构为它们的成员添加了新的作用域。如果由一个对象p，那么p.x就是指定的对象p中的x属性。

一般来说可以通过public、private和protected这样的关键字来显式的控制访问。像C++和Java这样的面向对象的语言可以通过限制访问来实现封装。

### 4.5 动态作用域

从技术上来讲，如果一个作用域策略依赖于一个或多个只有在程序执行时刻才能知道的元素，那么就说他是动态的。不过，术语的动态作用域一般是指：对一个名字x的使用是指向的最近被调用但还没有终止且声明了x的过程中的这个声明。这种类型的动态作用域一般只会在特殊情况下出现。

### 4.6 参数传递机制

1. 参数的值引用。这种传递会对实参进行求值（如果传递的是表达式）或拷贝。这些值会被放在属于被调用者的形参内存地址上。被调用的值的改变只限于被调用的过程中，不会改变实参的值。
2. 引用调用。此种调用中实参的内存地址会被传递到相应的形式参数上，。从而导致对形参的改变会作用在实参上。

### 4.7 别名

像引用调用和类似的其他方法会导致多个形式参数同时指向一个位置。这种情况下的变量为会被叫做另一个变量的别名。这样不论改变了谁的值都会反应在同一个内存位置上。
